% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/helpers.R
\name{accumulate_pred_trans}
\alias{accumulate_pred_trans}
\alias{transitively}
\title{Run predicates transitively}
\usage{
accumulate_pred_trans(.z, .lf, ...)

transitively(.p, ...)
}
\arguments{
\item{.z}{A list or atomic vector.}

\item{.lf}{A list of predicate functions.}

\item{...}{Additional named arguments to \code{.lf}.}

\item{.p}{A predicate function.}
}
\value{
A dataframe of logical vectors, one column per predicate function.
Skipped predicate tests return a \code{NA}.
}
\description{
Assumes that if a predicate on the left is \code{FALSE},
the succeeding one on the right will also be \code{FALSE}
and can thus be skipped.
}
\details{
When checking data (such as bibliometric metadata)
against several criteria of compliance (such as uniqueness, syntax),
two conditions can hold:
\enumerate{
\item The criteria is an \strong{aggregate phenomenon},
such as in the case of uniqueness.
It does not make sense to ask if any \emph{individual} data element is unique,
but the entire data vector must be unique.
Happily, this condition is "downward compatible":
If the criteria is an individual phenomenon (such as syntax),
it can also tested in vectorised form against the entire vector.
\item The criteria may be in some \strong{transitive order.}
For example, if a value \code{is.integer()} it will also be \code{is.numeric()};
an integer is a special case of a numeric value.
Typically, these criteria may be listed in decreasing order of generality:
You'd \emph{first} test if something is \code{is.numeric()}
and \emph{then} whether it's also \code{is.integer()}.
Formally, this means that predicate functions may be given in
\strong{negative transitive order},
where .lf\href{.z}{n} == FALSE\code{implies}.lf\href{.z}{n+1} == FALSE`.

Abstracting away these ordered predicates with functional programming
brings significant benefits:
\enumerate{
\item It saves computation.
If \code{.lf[n+1](.z)} is already known to be \code{FALSE},
it need not be run.
\item It helps improve expressiveness and reduces complexity of the
predicates.
}
}
}
\section{Related Functions and Methods}{
\subsection{Functions}{
\itemize{
\item \code{transitively}: Adverb to let predicate functions default to \code{NA} for \code{.x[!.prior]}.
Creates a function with two arguments:
\itemize{
\item \code{.x}: An object to apply \code{.p} to.
\item \code{.prior}: A logical vector,
where \code{FALSE} or \code{NA} implies that \code{.p(.x)} should not be run
but default to \code{NA}.
\item ...: Other arguments passed to \code{.p()}.
}
}}}

\seealso{
Other helpers: 
\code{\link{auth_cr}()},
\code{\link{auth_mailjet}()}
}
\concept{helpers}
